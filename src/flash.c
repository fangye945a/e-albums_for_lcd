#include "flash.h"
#include "func.h"
int color_table[8]=
			{
				0x000000ff,	//蓝色		0
				0x00ff00ff,	//紫色 		1
				0x0000ff00,	//绿色		2
				0x00ff0000,	//红色		3
				0x00ffff00,	//黄色		4
				0x0000ffff,	//天蓝色	5
				0x00ffffff,	//白色		6
				0x00000000	//黑色		7
			};

/******************************************************************
*********************  百叶窗(垂直)图片  ****************************
*******************************************************************/
int byc_bmp(char *tmp)    //百叶窗特效
{
	int x=0,y=0,i=0,j=0,k=0;
	for(k=0;k<50;k++)
	{
		for(x=k;x<800;x+=50)
		{
			for(y=0;y<480;y++)
			{
				i=4*x;
				j=3*x;
				ptr[x+800*(479-y)] = tmp[800*y*3+j+2]<<16|tmp[800*y*3+j+1]<<8|tmp[800*y*3+j];
			}
		}
		usleep(10000);
	}
	return 0;
}

/******************************************************************
*********************  显现图片  ****************************
*******************************************************************/
int clean_bmp()    //百叶窗特效
{
	int x=0,y=0,i=0,j=0,k=0;
	for(x=0;x<800;x++)
	{
		for(y=0;y<480;y++)
		{
			i=4*x;
			j=3*x;
			ptr[x+800*(479-y)]=color_table[6];
		}
	}
	return 0;
}
/******************************************************************
*********************  幕布特效从左往右  **************************
*******************************************************************/
int left_bmp(char *tmp)  
{
	int x=0,y=0,i=0,j=0;
	for(x=0;x<800;x++)
	{
		for(y=0;y<480;y++)
		{
			i=4*x;
			j=3*x;
			ptr[x+800*(479-y)]=tmp[800*y*3+j+2]<<16|tmp[800*y*3+j+1]<<8|tmp[800*y*3+j];
		}
		usleep(2000);
	}
	return 0;
}

/******************************************************************
*********************       锯齿百叶窗特效  ***************************
*******************************************************************/
int dc_bmp(char *tmp)    //锯齿百叶窗淡特效
{
	int x=0,y=0,i=0,j=0,k=0,m=0;
	for(k=0;k<10;k++)
	{
		for(m=9;m>=0;m--)
		{
			for(x=0;x<800;x++)
			{
				for(y=0;y<480;y++)
				{
					if(x%10==k && y%10==m)
					{
						i=4*x;
						j=3*x;
						ptr[x+800*(479-y)] = tmp[800*y*3+j+2]<<16|tmp[800*y*3+j+1]<<8|tmp[800*y*3+j];
					}
				}
			}
			usleep(200);
		}
	}
	return 0;
}

/******************************************************************
*********************  百叶窗(水平)读取图片  ****************************
*******************************************************************/
int byc_sp_bmp(char *tmp)    //百叶窗特效
{
	int x=0,y=0,i=0,j=0,k=0;
	for(k=0;k<20;k++)
	{
		for(y=k;y<480;y+=20)
		{
			for(x=0;x<800;x++)
			{
				i=4*x;
				j=3*x;
				ptr[x+800*(479-y)] = tmp[800*y*3+j+2]<<16|tmp[800*y*3+j+1]<<8|tmp[800*y*3+j];
			}
		}
		usleep(40000);
	}
	return 0;
}
/**********************************************************************
******************	  幕布特效（从下往上）	***************************
**********************************************************************/
int down_bmp(char *tmp)
{
	int x=0,y=0,i=0,j=0;
	for(y=0;y<480;y++)				//写入设备映射文件
	{
		for(x=0;x<800;x++)
		{
			i=4*x;
			j=3*x;
			ptr[x+800*(479-y)]=tmp[800*y*3+j+2]<<16|tmp[800*y*3+j+1]<<8|tmp[800*y*3+j];
		}
		usleep(2000);
	}
	return 0;
}
/**********************************************************************
******************	  （从中间往两边）	***************************
**********************************************************************/
int inside_out_bmp(char *tmp)
{
	int x=0,y=0,i=0,j=0;
	int k=0;
	for(k=400;k>=0;k-=8)
	{
		for(y=0;y<480;y++)				//写入设备映射文件
		{
			for(x=k;x<400+400-k;x++)
			{
				i=4*x;
				j=3*x;
				ptr[x+800*(479-y)]=tmp[800*y*3+j+2]<<16|tmp[800*y*3+j+1]<<8|tmp[800*y*3+j];
			}
		}
		usleep(4000);
	}
	return 0;
}

/***********************************************************************************************
*********************************	 添加颜色矩形色块	   ******************************************
***********************************************************************************************/
int add_color_line(int x_start,int y_start,int x_end,int y_end,int color) 	//添加颜色色块
{	

	int x=0,y=0;

	if((x_start<0) || (x_end>=800) || (y_start<0) || (y_end>=480)||(x_start>x_end)||(y_start>y_end))
	{
		printf("The pos is inllegal.\n");
		return -1;
	}
	for(y=y_start;y<=y_end;y++)	//int型双重循环赋值
	{
		for(x=x_start;x<=x_end;x++)
		{
			ptr[x+800*(479-y)]=color_table[color];
		}
	}
	return 0;
}
/***********************************************************************************************
*********************************	 添加颜色圆形色块  ******************************************
***********************************************************************************************/
int add_color_round(int x_start,int y_start,int x_end,int y_end,int color) 	//添加颜色圆形色块
{	

	int x=0,y=0,r=0;
	int x_m=0,y_m=0;
	x_m =(x_end + x_start)/2;
	y_m =(y_end + y_start)/2;

	printf("x_start = %d,y_start = %d\n",x_start,y_start);
	printf("x_end = %d,y_end = %d\n",x_end,y_end);
	printf("x_min = %d,y_min = %d\n",x_m,y_m);

	if((x_start<0) || (x_end>=800) || (y_start<0) || (y_end>=480)||(x_start>x_end)||(y_start>y_end))
	{
		printf("The pos is inllegal.\n");
		return -1;
	}
	if((x_end-x_start)>(y_end-y_start))
		r=(y_end-y_start)/2;
	else
		r=(x_end-x_start)/2;
	printf("r = %d",r);
	for(y=y_start;y<=y_end;y++)	//int型双重循环赋值
	{
		for(x=x_start;x<=x_end;x++)
		{
			if(fabs(x-x_m)*fabs(x-x_m)+fabs(y-y_m)*fabs(y-y_m) <= r*r)	
				ptr[x+800*(479-y)]=color_table[color];
		}
	}
	return 0;
}
